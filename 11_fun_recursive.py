# 在函数内部，可以调用其他的函数，如果一个函数在内部调用自己本身，这个函数就是递归函数。

#举个例子，计算阶乘：n! = 1*2*3*4*5*...*n，用函数fact(n)表示可以看出：
# fact(n) = 1*2*3*4*5*...*(n-1)*n = fact(n-1)*n
# 所以fact(n)可以表示为n*fact(n-1),只用n=1 时需要特殊处理。
def fact(n):
    if 1 == n:
        return 1
    return n * fact(n - 1)
print(fact(3))
print(fact(5))

# 递归函数的有点是定义简单，逻辑清晰，理论上，所有的递归函数都可以写成循环的方式，但是循环的逻辑不如递归清晰
# 使用递归函数时，需要注意防止栈溢出

# 递归函数中，有一种叫做尾递归，尾递归可以做优化，使的栈不会增长， 从而使得栈不会溢出（目前不会优化）
def fact_iter(num, sum):
    if 1 == num:
        return sum
    return fact_iter(num - 1, num * sum)
print(fact_iter(5, 1))

# 练习：汉诺塔的实现；编写move(n, a, b, c)函数，它接收参数n, 表示3个柱子，a, b, c中的第一个柱子a的盘子的数量，然后打印出把所有盘子从a借助b移动到c的方法：
# 汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。
def move(n, a, b, c):
    if(1 == n):
        print(a, '->', c)
    else:
        move(n-1, a, c, b)
        move(1, a, b, c)
        move(n-1,b, a, c)